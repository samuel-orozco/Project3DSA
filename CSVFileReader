#include <iostream>
#include <fstream>
#include <sstream>
#include <iostream>
#include <unordered_map>
using namespace std;

struct Node {
	string county;
	string state;
	string date;
	int fips;
	int cases;
	int deaths;

	// Caden's part for BST tree
	int BF = 0;
	Node* left = nullptr;
	Node* right = nullptr;
	Node() : county(""), state(""), date(""), fips(0), cases(0), deaths(0), BF(0), left(nullptr), right(nullptr) {}
	Node(string ct, string s, string d, int f, int c, int x) : county(ct), state(s), date(d), fips(f), cases(c), deaths(x), BF(0), left(nullptr), right(nullptr) {}
};


struct mapNode //had to make separate node because didn't need pointers
{
    string county;
    string state;
    string date;
    int fips;
    int cases;
    int deaths;

    mapNode(string s, string d, int f, int c, int x): state(s), date(d), fips(f), cases(c), deaths(x){};
};


Node* BSTinsert(Node* root, Node temp);
int max(int left, int right);
int height(Node* root);
int BalanceFactor(Node* root);
Node* rotateLeft(Node* root); // left rotate of AVL Tree
Node* rotateRight(Node* root); // right rotate of AVL Tree

void readCSVFile(const char* filepath, Node* &root, unordered_map& m);


int main() {
    Node* root = nullptr;

    unordered_map<string, mapNode> covidTracker; //using county as key

    readCSVFile("nameofCSVfile", root, covidTracker);

    bool isRunning = true;
    int choice;

    while (isRunning) {

        // cout menu of user options
        cout << "Welcome to the COVID-19 case tracker by county. Please choose from the following options." << endl;
        cout << "1. County with most cases\n2. County with most deaths\n"
                "3. Number of cases overall\n4. Number of deaths overall\n"
                "5. Specific county number of cases and deaths\n0. Exit Program" << endl;
        cin >> choice;
        switch (choice) {
        case 0: {
            cout << "Hope you got the information you needed! Stay safe Gator!" << endl;
            isRunning = false;
        }
        case 1: {
            topCaseCounty();
        }
        case 2: {
            topDeathCounty();
        }
        case 3: {
            overallCases();
        }
        case 4: {
            overallDeaths();
        }
        case 5: {
            cout << "Insert county name (using all capital letters)" << endl;
            string countyName;
            cin >> countyName;
            searchCountyName(countyName);
        }
        }

    }

    return 0;
}

void readCSVFile(const char* filepath, Node* &root, unordered_map& m) {
    ifstream file(filepath);
    if (file.is_open()) {
        string lineFromFile;
        getline(file, lineFromFile); //skips that first line
        while (!file.eof()) {
            getline(file, lineFromFile);
            istringstream stream(lineFromFile);
            string dateOfUpdate, County, State, Fips, caseCount, deathCount;
            getline(stream, dateOfUpdate, ',');
            getline(stream, County, ',');
            getline(stream, State, ',');
            getline(stream, Fips, ',');
            getline(stream, caseCount, ',');
            getline(stream, deathCount, ',');

            Node temp;
            temp.date = dateOfUpdate;
            temp.county = County;
            temp.state = State;
            temp.fips = stoi(Fips);
            temp.cases = stoi(caseCount);
            temp.deaths = stoi(deathCount);

            // only need to insert node into data structure
            //insert them into BST and HASH MAP

            root = BSTinsert(root, temp);

            m[County] = mapNode(State, dateOfUpdate, Fips, caseCount, deathCount); //will add or update map string/node pair
        }
    }
}

Node* BSTinsert(Node* root, Node temp) {
	//normal insert of BST
	if (root == nullptr) {
		return new Node(temp.county, temp.state, temp.date, temp.fips, temp.cases, temp.deaths);
	}
	if (temp.fips < root->fips)
		root->left = BSTinsert(root->left, temp);
	else if (temp.fips > root->fips)
		root->right = BSTinsert(root->right, temp);
	else {
		root->cases = temp.cases;
		root->deaths = temp.deaths;
		root->date = temp.date;
		return root;
	}
	/*
	//Balance the AVL Tree
	root->BF = BalanceFactor(root);

	if (root->BF > 1 && temp.fips < root->left->fips) { // Left Left Case
		root = rotateRight(root);
		return root;
	}
	if (root->BF < -1 && temp.fips > root->right->fips) { // Right Right Case
		root = rotateLeft(root);
		return root;
	}
	if (root->BF > 1 && temp.fips > root->left->fips) { // Left Right Case
		root->left = rotateLeft(root->left);
		root = rotateRight(root);
		return root;
	}
	if (root->BF < -1 && temp.fips < root->right->fips) { // Right Left Case
		root->right = rotateLeft(root->right);
		root = rotateLeft(root);
		return root;
	}*/
	return root;
}

int max(int left, int right) { // finds max of 2 numbers
    if (left > right)
        return left;
    return right;
}

int height(Node* root) { // finds height of node -> Height = 1 + max(Height(children))
    if (root == nullptr)
        return 0;
    return (1 + max(height(root->left), height(root->right)));
}

int BalanceFactor(Node* root) { // calculate balance factor of node
    return (height(root->left) - height(root->right));
}

Node* rotateLeft(Node* root) { // left rotate of AVL Tree
    Node* grandchild = root->right->left;
    Node* newParent = root->right;
    newParent->left = root;
    root->right = grandchild;
    return newParent;
}

Node* rotateRight(Node* root) { // right rotate of AVL Tree
    Node* grandchild = root->left->right;
    Node* newParent = root->left;
    newParent->right = root;
    root->left = grandchild;
    return newParent;
}
